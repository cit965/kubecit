// Code generated by protoc-gen-go-http. DO NOT EDIT.
// versions:
// - protoc-gen-go-http v2.7.0
// - protoc             v3.19.4
// source: helloworld/v1/cluster.proto

package v1

import (
	context "context"
	http "github.com/go-kratos/kratos/v2/transport/http"
	binding "github.com/go-kratos/kratos/v2/transport/http/binding"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the kratos package it is being compiled against.
var _ = new(context.Context)
var _ = binding.EncodeURL

const _ = http.SupportPackageIsVersion1

const OperationClusterClusterDelete = "/cluster.v1.Cluster/ClusterDelete"
const OperationClusterClusterGet = "/cluster.v1.Cluster/ClusterGet"
const OperationClusterClusterList = "/cluster.v1.Cluster/ClusterList"
const OperationClusterClusterRegister = "/cluster.v1.Cluster/ClusterRegister"
const OperationClusterClusterUpdate = "/cluster.v1.Cluster/ClusterUpdate"

type ClusterHTTPServer interface {
	// ClusterDelete Delete a cluster
	ClusterDelete(context.Context, *ClusterBase) (*ClusterDeleteResponse, error)
	// ClusterGet Get a cluster
	ClusterGet(context.Context, *ClusterBase) (*ClusterBase, error)
	// ClusterList List all clusters
	ClusterList(context.Context, *ClusterListRequest) (*ClusterListResponse, error)
	// ClusterRegister Register a cluster
	ClusterRegister(context.Context, *ClusterRegisterRequest) (*ClusterRegisterResponse, error)
	// ClusterUpdate Update a cluster
	ClusterUpdate(context.Context, *ClusterBase) (*ClusterBase, error)
}

func RegisterClusterHTTPServer(s *http.Server, srv ClusterHTTPServer) {
	r := s.Route("/")
	r.GET("/clusters", _Cluster_ClusterList0_HTTP_Handler(srv))
	r.POST("/cluster", _Cluster_ClusterRegister0_HTTP_Handler(srv))
	r.DELETE("/cluster/{id}", _Cluster_ClusterDelete0_HTTP_Handler(srv))
	r.GET("/cluster/{id}", _Cluster_ClusterGet0_HTTP_Handler(srv))
	r.PUT("/cluster/{id}", _Cluster_ClusterUpdate0_HTTP_Handler(srv))
}

func _Cluster_ClusterList0_HTTP_Handler(srv ClusterHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ClusterListRequest
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationClusterClusterList)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ClusterList(ctx, req.(*ClusterListRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ClusterListResponse)
		return ctx.Result(200, reply)
	}
}

func _Cluster_ClusterRegister0_HTTP_Handler(srv ClusterHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ClusterRegisterRequest
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationClusterClusterRegister)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ClusterRegister(ctx, req.(*ClusterRegisterRequest))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ClusterRegisterResponse)
		return ctx.Result(200, reply)
	}
}

func _Cluster_ClusterDelete0_HTTP_Handler(srv ClusterHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ClusterBase
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationClusterClusterDelete)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ClusterDelete(ctx, req.(*ClusterBase))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ClusterDeleteResponse)
		return ctx.Result(200, reply)
	}
}

func _Cluster_ClusterGet0_HTTP_Handler(srv ClusterHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ClusterBase
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationClusterClusterGet)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ClusterGet(ctx, req.(*ClusterBase))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ClusterBase)
		return ctx.Result(200, reply)
	}
}

func _Cluster_ClusterUpdate0_HTTP_Handler(srv ClusterHTTPServer) func(ctx http.Context) error {
	return func(ctx http.Context) error {
		var in ClusterBase
		if err := ctx.Bind(&in); err != nil {
			return err
		}
		if err := ctx.BindQuery(&in); err != nil {
			return err
		}
		if err := ctx.BindVars(&in); err != nil {
			return err
		}
		http.SetOperation(ctx, OperationClusterClusterUpdate)
		h := ctx.Middleware(func(ctx context.Context, req interface{}) (interface{}, error) {
			return srv.ClusterUpdate(ctx, req.(*ClusterBase))
		})
		out, err := h(ctx, &in)
		if err != nil {
			return err
		}
		reply := out.(*ClusterBase)
		return ctx.Result(200, reply)
	}
}

type ClusterHTTPClient interface {
	ClusterDelete(ctx context.Context, req *ClusterBase, opts ...http.CallOption) (rsp *ClusterDeleteResponse, err error)
	ClusterGet(ctx context.Context, req *ClusterBase, opts ...http.CallOption) (rsp *ClusterBase, err error)
	ClusterList(ctx context.Context, req *ClusterListRequest, opts ...http.CallOption) (rsp *ClusterListResponse, err error)
	ClusterRegister(ctx context.Context, req *ClusterRegisterRequest, opts ...http.CallOption) (rsp *ClusterRegisterResponse, err error)
	ClusterUpdate(ctx context.Context, req *ClusterBase, opts ...http.CallOption) (rsp *ClusterBase, err error)
}

type ClusterHTTPClientImpl struct {
	cc *http.Client
}

func NewClusterHTTPClient(client *http.Client) ClusterHTTPClient {
	return &ClusterHTTPClientImpl{client}
}

func (c *ClusterHTTPClientImpl) ClusterDelete(ctx context.Context, in *ClusterBase, opts ...http.CallOption) (*ClusterDeleteResponse, error) {
	var out ClusterDeleteResponse
	pattern := "/cluster/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationClusterClusterDelete))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "DELETE", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ClusterHTTPClientImpl) ClusterGet(ctx context.Context, in *ClusterBase, opts ...http.CallOption) (*ClusterBase, error) {
	var out ClusterBase
	pattern := "/cluster/{id}"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationClusterClusterGet))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ClusterHTTPClientImpl) ClusterList(ctx context.Context, in *ClusterListRequest, opts ...http.CallOption) (*ClusterListResponse, error) {
	var out ClusterListResponse
	pattern := "/clusters"
	path := binding.EncodeURL(pattern, in, true)
	opts = append(opts, http.Operation(OperationClusterClusterList))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "GET", path, nil, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ClusterHTTPClientImpl) ClusterRegister(ctx context.Context, in *ClusterRegisterRequest, opts ...http.CallOption) (*ClusterRegisterResponse, error) {
	var out ClusterRegisterResponse
	pattern := "/cluster"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationClusterClusterRegister))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "POST", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}

func (c *ClusterHTTPClientImpl) ClusterUpdate(ctx context.Context, in *ClusterBase, opts ...http.CallOption) (*ClusterBase, error) {
	var out ClusterBase
	pattern := "/cluster/{id}"
	path := binding.EncodeURL(pattern, in, false)
	opts = append(opts, http.Operation(OperationClusterClusterUpdate))
	opts = append(opts, http.PathTemplate(pattern))
	err := c.cc.Invoke(ctx, "PUT", path, in, &out, opts...)
	if err != nil {
		return nil, err
	}
	return &out, err
}
